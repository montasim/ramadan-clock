/**
 * Prayer Time Processor Service
 * Processes and validates prayer time data from API
 */

import type { PrayerTimeData } from '@/lib/api/prayer-time-api';
import { timeEntryArraySchema } from '@/lib/validations';
import type { TimeEntry } from '@/lib/db';

/**
 * Validation result for a single entry
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/**
 * Processing result
 */
export interface ProcessingResult {
  total: number;
  valid: number;
  invalid: number;
  entries: TimeEntry[];
  errors: Array<{ location: string; date: string; errors: string[] }>;
}

/**
 * Prayer Time Processor Service
 */
export class PrayerTimeProcessorService {
  /**
   * Strip timezone offset from time string
   * Handles formats like "05:30 (+06)", "05:30 (GMT+6)", "05:30 (BDT)"
   */
  private stripTimezoneOffset(time: string): string {
    if (!time) return time;
    
    // Remove anything after a space followed by parenthesis
    const spaceParenIndex = time.indexOf(' (');
    if (spaceParenIndex > 0) {
      return time.substring(0, spaceParenIndex);
    }
    
    // Remove anything after a parenthesis
    const parenIndex = time.indexOf('(');
    if (parenIndex > 0) {
      return time.substring(0, parenIndex).trim();
    }
    
    return time;
  }

  /**
   * Convert API prayer time data to TimeEntry format
   * Strips timezone offsets from times
   */
  convertToTimeEntry(apiData: PrayerTimeData): TimeEntry {
    return {
      id: '', // Will be generated by database
      date: apiData.date,
      sehri: this.stripTimezoneOffset(apiData.sehri),
      iftar: this.stripTimezoneOffset(apiData.iftar),
      location: apiData.location,
      createdAt: new Date(),
    };
  }

  /**
   * Validate a single time entry
   */
  validateTimeEntry(entry: TimeEntry): ValidationResult {
    const errors: string[] = [];

    // Validate date format (YYYY-MM-DD)
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(entry.date)) {
      errors.push(`Invalid date format: ${entry.date}`);
    } else {
      // Validate date is reasonable (between 2020 and 2030)
      const [year, month, day] = entry.date.split('-').map(Number);
      if (year < 2020 || year > 2030) {
        errors.push(`Date year out of range: ${year}`);
      }
      if (month < 1 || month > 12) {
        errors.push(`Invalid month: ${month}`);
      }
      if (day < 1 || day > 31) {
        errors.push(`Invalid day: ${day}`);
      }
    }

    // Validate time format (HH:mm) - Note: Aladhan API returns times like "04:45 (+06)"
    // Timezone offsets are stripped by convertToTimeEntry before validation
    const timeRegex = /^([01]\d|2[0-3]):([0-5]\d)$/;
    
    if (!timeRegex.test(entry.sehri)) {
      errors.push(`Invalid Sehri time format: ${entry.sehri}`);
    }

    if (!timeRegex.test(entry.iftar)) {
      errors.push(`Invalid Iftar time format: ${entry.iftar}`);
    }

    // Validate logical time order (Sehri should be before Iftar)
    if (timeRegex.test(entry.sehri) && timeRegex.test(entry.iftar)) {
      const [sehriHour, sehriMinute] = entry.sehri.split(':').map(Number);
      const [iftarHour, iftarMinute] = entry.iftar.split(':').map(Number);
      
      const sehriMinutes = sehriHour * 60 + sehriMinute;
      const iftarMinutes = iftarHour * 60 + iftarMinute;

      // Sehri should be before Iftar (in the same day)
      // Note: Sehri is typically early morning (e.g., 4:00 AM)
      // and Iftar is evening (e.g., 6:00 PM)
      if (sehriMinutes >= iftarMinutes) {
        errors.push(`Sehri time (${entry.sehri}) should be before Iftar time (${entry.iftar})`);
      }
    }

    // Validate location
    if (!entry.location || (typeof entry.location === 'string' && entry.location.trim().length === 0)) {
      errors.push('Location is required');
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Validate using Zod schema
   */
  validateWithZod(entry: TimeEntry): ValidationResult {
    const result = timeEntryArraySchema.safeParse([entry]);
    
    if (!result.success) {
      return {
        valid: false,
        errors: result.error.issues.map((issue) => issue.message),
      };
    }

    return {
      valid: true,
      errors: [],
    };
  }

  /**
   * Batch process API data for multiple locations
   */
  batchProcess(apiDataMap: Map<string, PrayerTimeData[]>): ProcessingResult {
    const result: ProcessingResult = {
      total: 0,
      valid: 0,
      invalid: 0,
      entries: [],
      errors: [],
    };

    for (const [location, prayerTimes] of apiDataMap.entries()) {
      for (const prayerTime of prayerTimes) {
        result.total++;

        const timeEntry = this.convertToTimeEntry(prayerTime);
        
        // Debug logging
        console.log(`[Processor] Processing entry:`, {
          location,
          date: prayerTime.date,
          sehri: prayerTime.sehri,
          iftar: prayerTime.iftar,
          timeEntry,
        });

        const validation = this.validateTimeEntry(timeEntry);
        const zodValidation = this.validateWithZod(timeEntry);

        // Combine validation errors
        const allErrors = [...validation.errors, ...zodValidation.errors];

        if (allErrors.length > 0) {
          console.log(`[Processor] Validation failed for ${location} ${prayerTime.date}:`, allErrors);
        }

        if (allErrors.length === 0) {
          result.valid++;
          result.entries.push(timeEntry);
        } else {
          result.invalid++;
          result.errors.push({
            location,
            date: prayerTime.date,
            errors: allErrors,
          });
        }
      }
    }

    return result;
  }

  /**
   * Filter entries by date range
   */
  filterByDateRange(
    entries: TimeEntry[],
    startDate: string,
    endDate: string
  ): TimeEntry[] {
    return entries.filter((entry) => {
      return entry.date >= startDate && entry.date <= endDate;
    });
  }

  /**
   * Filter entries by location
   */
  filterByLocation(entries: TimeEntry[], location: string): TimeEntry[] {
    return entries.filter((entry) => entry.location === location);
  }

  /**
   * Filter entries by multiple locations
   */
  filterByLocations(entries: TimeEntry[], locations: string[]): TimeEntry[] {
    return entries.filter((entry) => entry.location && locations.includes(entry.location));
  }

  /**
   * Remove duplicates from entries
   * Keeps the first occurrence of each date-location combination
   */
  removeDuplicates(entries: TimeEntry[]): TimeEntry[] {
    const seen = new Set<string>();
    const unique: TimeEntry[] = [];

    for (const entry of entries) {
      const key = `${entry.date}-${entry.location}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(entry);
      }
    }

    return unique;
  }

  /**
   * Sort entries by date and location
   */
  sortEntries(entries: TimeEntry[]): TimeEntry[] {
    return [...entries].sort((a, b) => {
      // First sort by date
      if (a.date !== b.date) {
        return a.date.localeCompare(b.date);
      }
      // Then sort by location
      return (a.location || '').localeCompare(b.location || '');
    });
  }

  /**
   * Group entries by location
   */
  groupByLocation(entries: TimeEntry[]): Map<string, TimeEntry[]> {
    const grouped = new Map<string, TimeEntry[]>();

    for (const entry of entries) {
      const location = entry.location || 'unknown';
      if (!grouped.has(location)) {
        grouped.set(location, []);
      }
      grouped.get(location)!.push(entry);
    }

    return grouped;
  }

  /**
   * Group entries by date
   */
  groupByDate(entries: TimeEntry[]): Map<string, TimeEntry[]> {
    const grouped = new Map<string, TimeEntry[]>();

    for (const entry of entries) {
      if (!grouped.has(entry.date)) {
        grouped.set(entry.date, []);
      }
      grouped.get(entry.date)!.push(entry);
    }

    return grouped;
  }

  /**
   * Get statistics about processed entries
   */
  getStatistics(entries: TimeEntry[]): {
    total: number;
    locations: number;
    dateRange: { start: string; end: string } | null;
    locationsList: string[];
  } {
    const locations = new Set(entries.map((e) => e.location).filter((l): l is string => l !== null));
    const dates = entries.map((e) => e.date).sort();

    return {
      total: entries.length,
      locations: locations.size,
      dateRange: dates.length > 0 ? { start: dates[0], end: dates[dates.length - 1] } : null,
      locationsList: Array.from(locations),
    };
  }
}

/**
 * Singleton instance of the processor service
 */
let processorInstance: PrayerTimeProcessorService | null = null;

export function getPrayerTimeProcessor(): PrayerTimeProcessorService {
  if (!processorInstance) {
    processorInstance = new PrayerTimeProcessorService();
  }
  return processorInstance;
}
